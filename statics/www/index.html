<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Tailon Console</title>
    <link rel="icon" type="image/x-icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./css/design-system.css" />
    <link rel="stylesheet" href="./css/app.css" />
    <script type="importmap">
      {
        "imports": {
          "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
          "vue-router": "https://unpkg.com/vue-router@4/dist/vue-router.esm-browser.js"
        }
      }
    </script>
    <script type="module">
      import { computed, createApp, onBeforeUnmount, onMounted, reactive, ref, watch } from 'vue'
      import { createRouter, createWebHashHistory, useRoute, useRouter } from 'vue-router'

      const STORAGE_KEYS = {
        baseUrl: 'tailon.baseUrl',
        headerName: 'tailon.headerName',
        headerValue: 'tailon.headerValue',
      }

      const initialBaseUrl =
        localStorage.getItem(STORAGE_KEYS.baseUrl) || window.location.origin.replace(/\/$/, '') || 'http://localhost:8080'

      const store = reactive({
        baseUrl: initialBaseUrl,
        extraHeaderName: localStorage.getItem(STORAGE_KEYS.headerName) || '',
        extraHeaderValue: localStorage.getItem(STORAGE_KEYS.headerValue) || '',
        queues: [],
        loadingQueues: false,
        selectedQueue: null,
        live: {
          controller: null,
          running: false,
          lines: [],
          raw: '',
          error: '',
        },
      })

      function normalizeBaseUrl(value) {
        if (!value) return ''
        return value.trim().replace(/\/$/, '')
      }

      function headersAny(accept = '*/*') {
        const h = { Accept: accept }
        if (store.extraHeaderName && store.extraHeaderValue) {
          h[store.extraHeaderName] = store.extraHeaderValue
        }
        return h
      }

      async function httpGet(path, accept = 'application/json') {
        const res = await fetch(`${store.baseUrl}${path}`, { headers: headersAny(accept) })
        if (!res.ok) throw new Error(`GET ${path} → ${res.status}`)
        if (accept === 'application/json') return res.json()
        return res.text()
      }

      async function httpPost(path, body, contentType = 'application/json') {
        const headers = headersAny('application/json')
        headers['Content-Type'] = contentType
        const res = await fetch(`${store.baseUrl}${path}`, { method: 'POST', headers, body })
        if (!res.ok) throw new Error(`POST ${path} → ${res.status}`)
        const ct = res.headers.get('content-type') || ''
        return ct.includes('application/json') ? res.json() : res.text()
      }

      async function httpDelete(path) {
        const res = await fetch(`${store.baseUrl}${path}`, { method: 'DELETE', headers: headersAny('application/json') })
        if (!res.ok) throw new Error(`DELETE ${path} → ${res.status}`)
        const ct = res.headers.get('content-type') || ''
        return ct.includes('application/json') ? res.json() : res.text()
      }

      async function listQueues() {
        store.loadingQueues = true
        try {
          const data = await httpGet('/v1/queues')
          store.queues = Array.isArray(data) ? data : []
        } finally {
          store.loadingQueues = false
        }
      }

      async function createQueue(name) {
        await httpPost('/v1/queues', JSON.stringify({ name }))
        await listQueues()
      }

      async function deleteQueue(id) {
        await httpDelete(`/v1/queues/${encodeURIComponent(id)}`)
        if (store.selectedQueue === id) {
          store.selectedQueue = null
        }
        await listQueues()
      }

      async function readJSONLStream(queueId, { onLine, maxLines = Infinity, timeoutMs = 30000 } = {}) {
        if (store.live.controller) {
          try {
            store.live.controller.abort()
          } catch (err) {
            console.warn('Abort anterior falló', err)
          }
        }
        store.live.controller = new AbortController()
        const { signal } = store.live.controller
        const url = `${store.baseUrl}/v1/queues/${encodeURIComponent(queueId)}:read`
        const res = await fetch(url, { headers: headersAny('*/*'), signal })
        if (!res.ok) throw new Error(`READ ${url} → ${res.status}`)

        const reader = res.body.getReader()
        const decoder = new TextDecoder()
        let buffer = ''
        let count = 0
        let timer

        const resetTimer = () => {
          if (timeoutMs !== Infinity) {
            if (timer) clearTimeout(timer)
            timer = setTimeout(() => {
              try {
                store.live.controller?.abort()
              } catch (err) {
                console.warn('Abort por timeout falló', err)
              }
            }, timeoutMs)
          }
        }

        resetTimer()

        try {
          while (true) {
            const { value, done } = await reader.read()
            if (done) break
            resetTimer()
            buffer += decoder.decode(value, { stream: true })
            let idx
            while ((idx = buffer.indexOf('\n')) >= 0) {
              const line = buffer.slice(0, idx)
              buffer = buffer.slice(idx + 1)
              if (!line.trim()) continue
              count += 1
              try {
                const parsed = JSON.parse(line)
                onLine && onLine(parsed, line)
              } catch (err) {
                onLine && onLine({ _raw: line }, line)
              }
              if (count >= maxLines) {
                try {
                  store.live.controller?.abort()
                } catch (err) {
                  console.warn('Abort por máximo falló', err)
                }
                return
              }
            }
          }
        } finally {
          if (timer) clearTimeout(timer)
        }
      }

      async function writeJSONLine(queueId, jsonText, contentType = 'application/json') {
        const body = contentType === 'application/json' ? `${jsonText.trim()}\n` : jsonText
        return httpPost(`/v1/queues/${encodeURIComponent(queueId)}:write`, body, contentType)
      }

      const Sidebar = {
        name: 'Sidebar',
        props: {
          open: { type: Boolean, default: false },
        },
        emits: ['close'],
        setup(props, { emit }) {
          const router = useRouter()
          const url = ref(store.baseUrl)
          const headerName = ref(store.extraHeaderName)
          const headerValue = ref(store.extraHeaderValue)
          const newQueue = ref('')
          const creating = ref(false)

          const mq = window.matchMedia ? window.matchMedia('(min-width: 1024px)') : null
          const isDesktop = ref(mq ? mq.matches : true)

          const handleMediaChange = (event) => {
            isDesktop.value = event.matches
            if (event.matches) {
              emit('close')
            }
          }

          mq?.addEventListener?.('change', handleMediaChange)

          onBeforeUnmount(() => {
            mq?.removeEventListener?.('change', handleMediaChange)
          })

          watch(
            () => store.baseUrl,
            (value) => {
              url.value = value
            },
            { immediate: true },
          )

          watch(
            () => store.extraHeaderName,
            (value) => {
              headerName.value = value
            },
            { immediate: true },
          )

          watch(
            () => store.extraHeaderValue,
            (value) => {
              headerValue.value = value
            },
            { immediate: true },
          )

          async function saveSettings() {
            store.baseUrl = normalizeBaseUrl(url.value)
            store.extraHeaderName = headerName.value.trim()
            store.extraHeaderValue = headerValue.value.trim()
            localStorage.setItem(STORAGE_KEYS.baseUrl, store.baseUrl)
            localStorage.setItem(STORAGE_KEYS.headerName, store.extraHeaderName)
            localStorage.setItem(STORAGE_KEYS.headerValue, store.extraHeaderValue)
          }

          async function testAuth() {
            try {
              await httpGet('/me')
              alert('Autenticación correcta (GET /me)')
            } catch (err) {
              alert(`Auth falló: ${err.message}`)
            }
          }

          async function addQueue() {
            if (!newQueue.value.trim()) return
            creating.value = true
            try {
              await createQueue(newQueue.value.trim())
              newQueue.value = ''
            } catch (err) {
              alert(`No se pudo crear la cola: ${err.message}`)
            } finally {
              creating.value = false
            }
          }

          function select(queue) {
            store.selectedQueue = queue
            router.push({ name: 'queue', params: { id: queue } })
            if (!isDesktop.value) {
              emit('close')
            }
          }

          onMounted(listQueues)

          return {
            store,
            url,
            headerName,
            headerValue,
            newQueue,
            creating,
            saveSettings,
            testAuth,
            addQueue,
            select,
            deleteQueue,
            listQueues,
            isDesktop,
            close: () => emit('close'),
          }
        },
        template: `
          <aside :class="['ds-sidebar', { 'is-open': open || isDesktop }]">
            <div class="ds-sidebar-header">
              <div class="ds-sidebar-brand">
                <strong>Tailon Console</strong>
                <span>Gestión de colas Hola Cloud</span>
              </div>
              <button type="button" class="hc-button hc-btn-subtle ds-hide-desktop" @click="close">Cerrar</button>
            </div>

            <section class="hc-card">
              <div class="ds-section-title">
                <div>
                  <p class="ds-tag">Conexión</p>
                  <h2 class="hc-heading-3">API Gateway</h2>
                </div>
              </div>
              <div class="ds-resource-picker">
                <div class="hc-input-wrapper">
                  <label class="hc-form-label" for="base-url">Base URL</label>
                  <input id="base-url" v-model="url" class="hc-input" type="url" placeholder="https://tailon.hola.cloud" />
                </div>
                <div class="ds-input-row">
                  <div class="hc-input-wrapper">
                    <label class="hc-form-label" for="header-name">Header</label>
                    <input id="header-name" v-model="headerName" class="hc-input" placeholder="X-Auth (opcional)" />
                  </div>
                  <div class="hc-input-wrapper">
                    <label class="hc-form-label" for="header-value">Valor</label>
                    <input id="header-value" v-model="headerValue" class="hc-input" placeholder="Token o API Key" />
                  </div>
                </div>
                <div class="ds-actions">
                  <button type="button" class="hc-button hc-btn-primary" @click="saveSettings">Guardar ajustes</button>
                  <button type="button" class="hc-button hc-btn-secondary" @click="testAuth">Probar /me</button>
                </div>
              </div>
            </section>

            <section class="hc-card">
              <div class="ds-section-title">
                <div>
                  <p class="ds-tag">Nueva cola</p>
                  <h2 class="hc-heading-3">Crear recurso</h2>
                </div>
              </div>
              <div class="ds-input-row">
                <div class="hc-input-wrapper" style="flex: 1 1 auto;">
                  <label class="hc-form-label" for="queue-name">Nombre</label>
                  <input id="queue-name" v-model="newQueue" class="hc-input" placeholder="payments.events" />
                </div>
                <div class="hc-input-wrapper" style="align-self: end;">
                  <button type="button" class="hc-button hc-btn-primary" :disabled="creating" @click="addQueue">
                    {{ creating ? 'Creando…' : 'Crear' }}
                  </button>
                </div>
              </div>
              <p class="hc-helper-text">Los nombres deben ser únicos. Se crean bajo demanda.</p>
            </section>

            <section class="hc-card">
              <div class="ds-section-title">
                <div>
                  <p class="ds-tag">Explorar</p>
                  <h2 class="hc-heading-3">Colas disponibles</h2>
                </div>
                <button type="button" class="hc-button hc-btn-subtle" @click="listQueues">Actualizar</button>
              </div>
              <div v-if="store.loadingQueues" class="ds-empty-state">Cargando colas…</div>
              <div v-else-if="!store.queues.length" class="ds-empty-state">Aún no hay colas creadas.</div>
              <ul v-else class="ds-queue-list">
                <li v-for="queue in store.queues" :key="queue" :class="['ds-queue-item', { 'is-active': store.selectedQueue === queue }]" @click="select(queue)">
                  <span class="ds-queue-name ds-monospace" :title="queue">{{ queue }}</span>
                  <button type="button" class="hc-button hc-btn-danger" title="Eliminar" @click.stop="deleteQueue(queue).catch(err => alert('Error al eliminar: ' + err.message))">Eliminar</button>
                </li>
              </ul>
            </section>

            <footer class="ds-sidebar-footer">
              <span>Autenticado contra <strong>{{ store.baseUrl || '—' }}</strong></span>
              <span>Tailon Console · Hola Cloud</span>
            </footer>
          </aside>
        `,
      }

      const Home = {
        name: 'Home',
        template: `
          <section class="ds-view">
            <header class="ds-main-header">
              <div>
                <span class="ds-tag">Tailon Console</span>
                <h1 class="hc-heading-2">Bienvenido</h1>
                <p class="hc-helper-text">Selecciona o crea una cola en el panel izquierdo para comenzar.</p>
              </div>
            </header>
            <div class="ds-main-content">
              <div class="ds-empty-state">
                Gestiona tus colas Hola Cloud desde la barra lateral. También puedes probar la API directamente desde aquí.
              </div>
            </div>
          </section>
        `,
      }

      const QueueView = {
        name: 'QueueView',
        setup() {
          const route = useRoute()
          const router = useRouter()
          const queueId = computed(() => route.params.id)
          const n = ref(10)
          const timeoutMs = ref(30000)
          const sending = ref(false)
          const contentType = ref('application/json')
          const newMessage = ref('{"hello":"world"}')

          function resetBuffer() {
            store.live.lines = []
            store.live.raw = ''
            store.live.error = ''
          }

          async function readN() {
            if (!queueId.value) return
            resetBuffer()
            try {
              await readJSONLStream(queueId.value, {
                maxLines: Number(n.value) || 1,
                timeoutMs: Number(timeoutMs.value) || 30000,
                onLine(obj, raw) {
                  store.live.lines.unshift(obj)
                  store.live.raw += `${raw}\n`
                },
              })
            } catch (err) {
              store.live.error = err.message
            }
          }

          async function toggleLive() {
            if (!queueId.value) return
            if (store.live.running) {
              try {
                store.live.controller?.abort()
              } catch (err) {
                console.warn('Abort manual falló', err)
              }
              store.live.running = false
              return
            }
            resetBuffer()
            store.live.running = true
            try {
              await readJSONLStream(queueId.value, {
                maxLines: Infinity,
                timeoutMs: Infinity,
                onLine(obj, raw) {
                  store.live.lines.unshift(obj)
                  store.live.raw += `${raw}\n`
                },
              })
            } catch (err) {
              store.live.error = err.message
            } finally {
              store.live.running = false
            }
          }

          async function sendMessage() {
            if (!queueId.value || !newMessage.value) return
            sending.value = true
            try {
              await writeJSONLine(queueId.value, newMessage.value, contentType.value)
            } catch (err) {
              alert(`Error al enviar: ${err.message}`)
            } finally {
              sending.value = false
            }
          }

          const curlCmd = computed(() => {
            if (!queueId.value) return ''
            const base = `${store.baseUrl}/v1/queues/${encodeURIComponent(queueId.value)}:read`
            const header = store.extraHeaderName && store.extraHeaderValue ? ` -H "${store.extraHeaderName}: ${store.extraHeaderValue}"` : ''
            return `curl -N -s${header} "${base}"`
          })

          async function copyCurl() {
            if (!curlCmd.value) return
            try {
              await navigator.clipboard.writeText(curlCmd.value)
              alert('Comando copiado al portapapeles')
            } catch (err) {
              alert('No se pudo copiar el comando: ' + err.message)
            }
          }

          watch(
            queueId,
            (value) => {
              if (!value) {
                router.replace({ name: 'home' })
                return
              }
              store.selectedQueue = value
              resetBuffer()
            },
            { immediate: true },
          )

          onMounted(() => {
            if (!store.queues.length) {
              listQueues()
            }
          })

          return {
            store,
            queueId,
            n,
            timeoutMs,
            newMessage,
            contentType,
            sending,
            readN,
            toggleLive,
            sendMessage,
            resetBuffer,
            curlCmd,
            copyCurl,
          }
        },
        template: `
          <section class="ds-view" v-if="queueId">
            <header class="ds-main-header">
              <div>
                <span class="ds-tag">Cola seleccionada</span>
                <h1 class="hc-heading-2 ds-monospace">{{ queueId }}</h1>
                <div class="ds-meta">
                  <span><strong>{{ store.live.lines.length }}</strong> en buffer</span>
                  <span v-if="store.live.running" class="ds-tag">LIVE activo</span>
                  <span>Timeout: {{ timeoutMs }} ms</span>
                </div>
              </div>
              <div class="ds-actions">
                <button type="button" class="hc-button hc-btn-secondary" @click="resetBuffer">Limpiar buffer</button>
                <button type="button" class="hc-button" :class="store.live.running ? 'hc-btn-danger' : 'hc-btn-primary'" @click="toggleLive">
                  {{ store.live.running ? 'Detener LIVE' : 'Iniciar LIVE' }}
                </button>
              </div>
            </header>

            <div class="ds-main-content">
              <div class="ds-card-grid">
                <section class="hc-card">
                  <div class="ds-section-title">
                    <div>
                      <h2 class="hc-heading-3">Obtener mensajes</h2>
                      <p class="hc-helper-text">Realiza una lectura puntual de la cola.</p>
                    </div>
                  </div>
                  <div class="ds-input-row">
                    <div class="hc-input-wrapper">
                      <label class="hc-form-label" for="queue-n">Siguientes N</label>
                      <input id="queue-n" v-model.number="n" type="number" min="1" class="hc-input" />
                    </div>
                    <div class="hc-input-wrapper">
                      <label class="hc-form-label" for="queue-timeout">Timeout (ms)</label>
                      <input id="queue-timeout" v-model.number="timeoutMs" type="number" min="0" class="hc-input" />
                    </div>
                  </div>
                  <div class="ds-actions">
                    <button type="button" class="hc-button hc-btn-secondary" @click="readN">Leer ahora</button>
                  </div>
                  <p v-if="store.live.error" class="hc-error-text">{{ store.live.error }}</p>
                </section>

                <section class="hc-card">
                  <div class="ds-section-title">
                    <div>
                      <h2 class="hc-heading-3">Crear mensaje</h2>
                      <p class="hc-helper-text">Se añadirá una línea al stream.</p>
                    </div>
                  </div>
                  <div class="ds-input-row">
                    <div class="hc-input-wrapper">
                      <label class="hc-form-label" for="content-type">Content-Type</label>
                      <select id="content-type" v-model="contentType" class="hc-input">
                        <option value="application/json">application/json</option>
                        <option value="text/plain">text/plain</option>
                      </select>
                    </div>
                  </div>
                  <div class="hc-input-wrapper">
                    <label class="hc-form-label" for="new-message">Payload</label>
                    <textarea id="new-message" v-model="newMessage" class="hc-input ds-monospace" rows="8" spellcheck="false"></textarea>
                    <p class="hc-helper-text">Con <code class="ds-inline">application/json</code> se agregará un salto de línea automático.</p>
                  </div>
                  <div class="ds-actions">
                    <button type="button" class="hc-button hc-btn-primary" :disabled="sending" @click="sendMessage">
                      {{ sending ? 'Enviando…' : 'Enviar mensaje' }}
                    </button>
                  </div>
                </section>

                <section class="hc-card">
                  <div class="ds-section-title">
                    <div>
                      <h2 class="hc-heading-3">Integración rápida</h2>
                      <p class="hc-helper-text">Usa cURL para consumir el stream en consola.</p>
                    </div>
                    <button type="button" class="hc-button hc-btn-subtle" @click="copyCurl">Copiar cURL</button>
                  </div>
                  <pre class="ds-curl ds-monospace">{{ curlCmd }}</pre>
                </section>
              </div>

              <section class="ds-message-feed">
                <div class="ds-section-title">
                  <div>
                    <h2 class="hc-heading-3">Mensajes recibidos</h2>
                    <p class="hc-helper-text">Los más recientes aparecen primero.</p>
                  </div>
                  <span class="hc-badge">{{ store.live.lines.length }}</span>
                </div>
                <div class="ds-message-list">
                  <template v-if="store.live.lines.length">
                    <ul>
                      <li v-for="(message, index) in store.live.lines" :key="index">
                        <pre class="ds-monospace">{{ JSON.stringify(message, null, 2) }}</pre>
                      </li>
                    </ul>
                  </template>
                  <div v-else class="ds-empty-messages">Aún no hay mensajes. Lanza una lectura o activa el modo LIVE.</div>
                </div>
              </section>
            </div>
          </section>
        `,
      }

      const routes = [
        { path: '/', name: 'home', component: Home },
        { path: '/queue/:id', name: 'queue', component: QueueView, props: true },
      ]

      const router = createRouter({ history: createWebHashHistory(), routes })

      const App = {
        name: 'App',
        components: { Sidebar },
        setup() {
          const sidebarOpen = ref(false)

          function openSidebar() {
            sidebarOpen.value = true
          }

          function closeSidebar() {
            sidebarOpen.value = false
          }

          onMounted(() => {
            listQueues().then(() => {
              if (store.queues.length && router.currentRoute.value.name === 'home') {
                const first = store.queues[0]
                store.selectedQueue = first
                router.replace({ name: 'queue', params: { id: first } })
              }
            })
          })

          return {
            store,
            sidebarOpen,
            openSidebar,
            closeSidebar,
          }
        },
        template: `
          <div class="ds-shell">
            <button type="button" class="hc-button hc-btn-primary ds-mobile-toggle" @click="openSidebar">Colas</button>
            <Sidebar :open="sidebarOpen" @close="closeSidebar" />
            <div v-if="sidebarOpen" class="ds-sidebar-overlay ds-hide-desktop" @click="closeSidebar"></div>
            <main class="ds-main">
              <router-view />
            </main>
          </div>
        `,
      }

      createApp(App).use(router).mount('#app')
    </script>
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>
