<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Tailon Console</title>
    <link rel="stylesheet" href="./lib/hc-design-system.css" />
    <link rel="stylesheet" href="./lib/app.css" />
    <script type="importmap">
      {
        "imports": {
          "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
          "vue-router": "https://unpkg.com/vue-router@4/dist/vue-router.esm-browser.js",
          "@vue/devtools-api": "https://unpkg.com/@vue/devtools-api@6.5.0/lib/esm/index.js"
        }
      }
    </script>
    <script type="module">
      import {
        computed,
        createApp,
        onMounted,
        reactive,
        ref,
        watch,
      } from 'vue'
      import { createRouter, createWebHashHistory, useRoute, useRouter } from 'vue-router'

      const storedBaseUrl = localStorage.getItem('tailon.baseUrl')
      const store = reactive({
        baseUrl: storedBaseUrl ? storedBaseUrl.replace(/\/$/, '') : 'http://localhost:8080',
        extraHeaderName: localStorage.getItem('tailon.headerName') || '',
        extraHeaderValue: localStorage.getItem('tailon.headerValue') || '',
        queues: [],
        loadingQueues: false,
        selectedQueue: null,
        live: {
          controller: null,
          running: false,
          lines: [],
          raw: '',
          error: '',
        },
      })

      function headersJSON() {
        const headers = {
          Accept: 'application/json',
          'Content-Type': 'application/json',
        }
        if (store.extraHeaderName && store.extraHeaderValue) {
          headers[store.extraHeaderName] = store.extraHeaderValue
        }
        return headers
      }

      function headersAny(accept = '*/*') {
        const headers = { Accept: accept }
        if (store.extraHeaderName && store.extraHeaderValue) {
          headers[store.extraHeaderName] = store.extraHeaderValue
        }
        return headers
      }

      async function httpGet(path, accept = 'application/json') {
        const response = await fetch(`${store.baseUrl}${path}`, { headers: headersAny(accept) })
        if (!response.ok) throw new Error(`GET ${path} → ${response.status}`)
        if (accept === 'application/json') return response.json()
        return response.text()
      }

      async function httpPost(path, body, contentType = 'application/json') {
        const headers = headersJSON()
        headers['Content-Type'] = contentType
        const response = await fetch(`${store.baseUrl}${path}`, {
          method: 'POST',
          headers,
          body,
        })
        if (!response.ok) throw new Error(`POST ${path} → ${response.status}`)
        const ct = response.headers.get('content-type') || ''
        return ct.includes('application/json') ? response.json() : response.text()
      }

      async function httpDelete(path) {
        const response = await fetch(`${store.baseUrl}${path}`, {
          method: 'DELETE',
          headers: headersAny('application/json'),
        })
        if (!response.ok) throw new Error(`DELETE ${path} → ${response.status}`)
        const ct = response.headers.get('content-type') || ''
        return ct.includes('application/json') ? response.json() : response.text()
      }

      async function listQueues() {
        store.loadingQueues = true
        try {
          const data = await httpGet('/v1/queues')
          store.queues = Array.isArray(data) ? data : []
        } finally {
          store.loadingQueues = false
        }
      }

      async function createQueue(name) {
        await httpPost('/v1/queues', JSON.stringify({ name }))
        await listQueues()
      }

      async function deleteQueue(id) {
        await httpDelete(`/v1/queues/${encodeURIComponent(id)}`)
        if (store.selectedQueue === id) store.selectedQueue = null
        await listQueues()
      }

      async function readJSONLStream(queueId, { onLine, maxLines = Infinity, timeoutMs = 30000 } = {}) {
        if (store.live.controller) {
          try {
            store.live.controller.abort()
          } catch (error) {
            console.warn('Abort anterior falló', error)
          }
        }
        store.live.controller = new AbortController()
        const { signal } = store.live.controller
        const url = `${store.baseUrl}/v1/queues/${encodeURIComponent(queueId)}:read`
        const response = await fetch(url, { headers: headersAny('*/*'), signal })
        if (!response.ok) throw new Error(`READ ${url} → ${response.status}`)

        const reader = response.body.getReader()
        const decoder = new TextDecoder()
        let buffer = ''
        let count = 0
        let timer

        const resetTimer = () => {
          if (timeoutMs === Infinity) return
          if (timer) clearTimeout(timer)
          timer = setTimeout(() => {
            try {
              store.live.controller.abort()
            } catch (error) {
              console.warn('Abort por timeout falló', error)
            }
          }, timeoutMs)
        }

        resetTimer()

        try {
          while (true) {
            const { value, done } = await reader.read()
            if (done) break
            resetTimer()
            buffer += decoder.decode(value, { stream: true })
            let idx
            while ((idx = buffer.indexOf('\n')) >= 0) {
              const line = buffer.slice(0, idx)
              buffer = buffer.slice(idx + 1)
              if (!line.trim()) continue
              count += 1
              try {
                const parsed = JSON.parse(line)
                onLine?.(parsed, line)
              } catch (error) {
                onLine?.({ _raw: line }, line)
              }
              if (count >= maxLines) {
                try {
                  store.live.controller.abort()
                } catch (error) {
                  console.warn('Abort por límite falló', error)
                }
                return
              }
            }
          }
        } finally {
          if (timer) clearTimeout(timer)
        }
      }

      async function writeJSONLine(queueId, jsonText, contentType = 'application/json') {
        const body = contentType === 'application/json' ? `${jsonText.trim()}\n` : jsonText
        return httpPost(`/v1/queues/${encodeURIComponent(queueId)}:write`, body, contentType)
      }

      const SettingsBar = {
        name: 'SettingsBar',
        setup() {
          const url = ref(store.baseUrl)
          const headerName = ref(store.extraHeaderName)
          const headerValue = ref(store.extraHeaderValue)

          function persist() {
            const normalized = url.value.trim().replace(/\/$/, '')
            if (normalized) {
              store.baseUrl = normalized
            }
            url.value = store.baseUrl
            store.extraHeaderName = headerName.value.trim()
            store.extraHeaderValue = headerValue.value.trim()
            localStorage.setItem('tailon.baseUrl', store.baseUrl)
            localStorage.setItem('tailon.headerName', store.extraHeaderName)
            localStorage.setItem('tailon.headerValue', store.extraHeaderValue)
          }

          async function testAuth() {
            try {
              await httpGet('/me')
              alert('Autenticación correcta con /me')
            } catch (error) {
              alert(`Auth falló: ${error.message}`)
            }
          }

          return { url, headerName, headerValue, persist, testAuth }
        },
        template: `
          <section class="hc-card settings-group">
            <div>
              <span class="text-muted" aria-hidden="true">Configuración de API</span>
              <h2 class="hc-heading-3">Conexión</h2>
            </div>
            <label class="hc-input-wrapper">
              <span class="hc-form-label">Base URL</span>
              <input v-model="url" class="hc-input" placeholder="https://tailon.hola.cloud" />
            </label>
            <div class="settings-inline">
              <label class="hc-input-wrapper">
                <span class="hc-form-label">Header (opcional)</span>
                <input v-model="headerName" class="hc-input" placeholder="X-Auth" />
              </label>
              <label class="hc-input-wrapper">
                <span class="hc-form-label">Valor del header</span>
                <input v-model="headerValue" class="hc-input" placeholder="Token o valor" />
              </label>
            </div>
            <div class="settings-actions">
              <button type="button" class="hc-button hc-btn-primary button-sm" @click="persist">Guardar preferencia</button>
              <button type="button" class="hc-button hc-btn-secondary button-sm" @click="testAuth">Probar /me</button>
            </div>
          </section>
        `,
      }

      const Sidebar = {
        name: 'Sidebar',
        components: { SettingsBar },
        setup() {
          const newQueue = ref('')
          const creating = ref(false)
          const router = useRouter()

          function select(queue) {
            store.selectedQueue = queue
            router.push({ name: 'queue', params: { id: queue } })
          }

          async function create() {
            if (!newQueue.value.trim()) return
            creating.value = true
            try {
              await createQueue(newQueue.value.trim())
              newQueue.value = ''
            } catch (error) {
              alert(`No se pudo crear la cola: ${error.message}`)
            } finally {
              creating.value = false
            }
          }

          onMounted(listQueues)

          return { store, newQueue, creating, create, select, deleteQueue, listQueues }
        },
        template: `
          <aside class="app-sidebar" aria-label="Panel lateral">
            <header class="app-sidebar__header">
              <h1>Tailon Console</h1>
              <p>Administra colas y mensajes JSONL.</p>
            </header>
            <div class="app-sidebar__scroll">
              <SettingsBar />
              <section class="hc-card queue-create">
                <div>
                  <span class="text-muted">Nueva cola</span>
                  <h2 class="hc-heading-3">Crear cola</h2>
                </div>
                <label class="hc-input-wrapper">
                  <span class="hc-form-label">Nombre</span>
                  <input v-model="newQueue" class="hc-input" placeholder="cola-principal" />
                </label>
                <div class="settings-actions">
                  <button type="button" class="hc-button hc-btn-primary button-sm" :disabled="creating" @click="create">
                    {{ creating ? 'Creando…' : 'Crear cola' }}
                  </button>
                </div>
              </section>
              <section class="hc-card stack" aria-live="polite">
                <header class="queue-toolbar">
                  <span>Colas registradas</span>
                  <button type="button" class="hc-button hc-btn-subtle button-sm" @click="listQueues">Refrescar</button>
                </header>
                <div v-if="store.loadingQueues" class="queue-loading">Cargando colas…</div>
                <div v-else-if="!store.queues.length" class="queue-empty">No hay colas configuradas todavía.</div>
                <ul v-else class="queue-list">
                  <li v-for="queue in store.queues" :key="queue">
                    <div
                      class="queue-item"
                      :class="{ 'is-active': store.selectedQueue === queue }"
                      @click="select(queue)"
                    >
                      <span class="queue-item__name" :title="queue">{{ queue }}</span>
                      <div class="queue-item__actions">
                        <button
                          type="button"
                          class="hc-button hc-btn-secondary button-icon"
                          title="Ver cola"
                          @click.stop="select(queue)"
                        >Abrir</button>
                        <button
                          type="button"
                          class="hc-button hc-btn-danger button-icon"
                          title="Eliminar cola"
                          @click.stop="deleteQueue(queue).catch(error => alert('Error al eliminar: ' + error.message))"
                        >Eliminar</button>
                      </div>
                    </div>
                  </li>
                </ul>
              </section>
            </div>
            <footer class="app-sidebar__footer">Tailon Console · Vue 3</footer>
          </aside>
        `,
      }

      const Home = {
        name: 'Home',
        template: `
          <section class="queue-home">
            <h2 class="hc-heading-2">Bienvenido</h2>
            <p>Selecciona una cola en el panel lateral o crea una nueva para empezar a recibir mensajes.</p>
            <p class="text-muted">Todos los cambios de conexión y cabeceras se guardan localmente en el navegador.</p>
          </section>
        `,
      }

      const QueueView = {
        name: 'QueueView',
        setup() {
          const route = useRoute()
          const queueId = computed(() => route.params.id)
          const itemsToRead = ref(10)
          const timeoutMs = ref(30000)
          const sending = ref(false)
          const contentType = ref('application/json')
          const newMessage = ref('{"hello":"world"}')

          function resetBuffer() {
            store.live.lines = []
            store.live.raw = ''
            store.live.error = ''
          }

          async function readN() {
            resetBuffer()
            try {
              await readJSONLStream(queueId.value, {
                maxLines: Number(itemsToRead.value) || 1,
                timeoutMs: Number(timeoutMs.value) || 30000,
                onLine(message, raw) {
                  store.live.lines.unshift(message)
                  store.live.raw += `${raw}\n`
                },
              })
            } catch (error) {
              store.live.error = error.message
            }
          }

          async function toggleLive() {
            if (store.live.running) {
              try {
                store.live.controller?.abort()
              } catch (error) {
                console.warn('Abort manual falló', error)
              }
              store.live.running = false
              return
            }
            resetBuffer()
            store.live.running = true
            try {
              await readJSONLStream(queueId.value, {
                maxLines: Infinity,
                timeoutMs: Infinity,
                onLine(message, raw) {
                  store.live.lines.unshift(message)
                  store.live.raw += `${raw}\n`
                },
              })
            } catch (error) {
              store.live.error = error.message
            } finally {
              store.live.running = false
            }
          }

          async function sendMessage() {
            sending.value = true
            try {
              await writeJSONLine(queueId.value, newMessage.value, contentType.value)
            } catch (error) {
              alert(`Error al enviar: ${error.message}`)
            } finally {
              sending.value = false
            }
          }

          watch(queueId, (value) => {
            store.selectedQueue = value
            resetBuffer()
          }, { immediate: true })

          const curlCmd = computed(() => {
            const url = `${store.baseUrl}/v1/queues/${encodeURIComponent(queueId.value)}:read`
            const header = store.extraHeaderName && store.extraHeaderValue
              ? ` -H \"${store.extraHeaderName}: ${store.extraHeaderValue}\"`
              : ''
            return `curl -N -s${header} \"${url}\"`
          })

          return {
            store,
            queueId,
            itemsToRead,
            timeoutMs,
            newMessage,
            contentType,
            sending,
            readN,
            toggleLive,
            sendMessage,
            curlCmd,
            resetBuffer,
          }
        },
        template: `
          <section class="queue-page" aria-live="polite">
            <header class="queue-page__header">
              <div>
                <h2>Cola <span class="hc-mono">{{ queueId }}</span></h2>
                <small>Lectura en streaming y publicación de eventos JSON Lines.</small>
              </div>
              <div class="queue-page__header-actions">
                <span class="badge-live" :class="{ 'is-active': store.live.running }">
                  {{ store.live.running ? 'Live activo' : 'Live detenido' }}
                </span>
                <button type="button" class="hc-button hc-btn-subtle button-sm" @click="resetBuffer">Limpiar</button>
                <button
                  type="button"
                  class="hc-button button-sm"
                  :class="store.live.running ? 'hc-btn-danger' : 'hc-btn-primary'"
                  @click="toggleLive"
                >{{ store.live.running ? 'Detener LIVE' : 'Iniciar LIVE' }}</button>
              </div>
            </header>
            <div class="queue-page__body">
              <div class="stack">
                <section class="hc-card form-grid">
                  <div>
                    <h3 class="hc-heading-3">Obtener mensajes</h3>
                    <p class="text-muted">Lee un número finito de elementos y detiene la conexión automáticamente.</p>
                  </div>
                  <div class="settings-inline">
                    <label class="hc-input-wrapper">
                      <span class="hc-form-label">Siguientes N</span>
                      <input v-model.number="itemsToRead" class="hc-input" min="1" type="number" />
                    </label>
                    <label class="hc-input-wrapper">
                      <span class="hc-form-label">Timeout (ms)</span>
                      <input v-model.number="timeoutMs" class="hc-input" min="0" type="number" />
                    </label>
                  </div>
                  <div class="settings-actions">
                    <button type="button" class="hc-button hc-btn-primary button-sm" @click="readN">Leer mensajes</button>
                    <p v-if="store.live.error" class="hc-error-text">{{ store.live.error }}</p>
                  </div>
                </section>

                <section class="hc-card form-grid">
                  <div>
                    <h3 class="hc-heading-3">Publicar mensaje</h3>
                    <p class="text-muted">El contenido se enviará como una sola línea para respetar el formato JSONL.</p>
                  </div>
                  <label class="hc-input-wrapper">
                    <span class="hc-form-label">Content-Type</span>
                    <select v-model="contentType" class="hc-input">
                      <option value="application/json">application/json</option>
                      <option value="text/plain">text/plain</option>
                    </select>
                  </label>
                  <label class="hc-input-wrapper">
                    <span class="hc-form-label">Contenido</span>
                    <textarea v-model="newMessage" class="hc-input" spellcheck="false"></textarea>
                    <small class="code-hint">Si seleccionas <code>application/json</code> se añadirá un salto de línea automáticamente.</small>
                  </label>
                  <div class="settings-actions">
                    <button
                      type="button"
                      class="hc-button hc-btn-primary button-sm"
                      :disabled="sending"
                      @click="sendMessage"
                    >{{ sending ? 'Enviando…' : 'Enviar mensaje' }}</button>
                  </div>
                </section>

                <section class="hc-card">
                  <div>
                    <h3 class="hc-heading-3">Escucha con cURL</h3>
                    <p class="text-muted">Usa este comando para suscribirte al stream desde tu terminal.</p>
                  </div>
                  <pre class="code-block"><code>{{ curlCmd }}</code></pre>
                </section>
              </div>

              <section class="hc-card message-card">
                <div class="message-header">
                  <h3 class="hc-heading-3">Mensajes recibidos</h3>
                  <span>{{ store.live.lines.length }} elementos</span>
                </div>
                <div class="message-scroll">
                  <ul class="message-list">
                    <li v-for="(message, index) in store.live.lines" :key="index" class="message-item">
                      <pre>{{ JSON.stringify(message, null, 2) }}</pre>
                    </li>
                    <li v-if="!store.live.lines.length" class="message-empty">
                      Aún no hay datos. Ejecuta una lectura o activa el modo LIVE.
                    </li>
                  </ul>
                </div>
              </section>
            </div>
          </section>
        `,
      }

      const routes = [
        { path: '/', name: 'home', component: Home },
        { path: '/queue/:id', name: 'queue', component: QueueView, props: true },
      ]

      const router = createRouter({ history: createWebHashHistory(), routes })

      const App = {
        name: 'App',
        components: { Sidebar },
        setup() {
          onMounted(async () => {
            await listQueues()
            if (store.queues.length && router.currentRoute.value.name === 'home') {
              const queue = store.queues[0]
              store.selectedQueue = queue
              router.replace({ name: 'queue', params: { id: queue } })
            }
          })
          return { store }
        },
        template: `
          <div class="app-shell">
            <Sidebar />
            <main class="app-main">
              <router-view />
            </main>
          </div>
        `,
      }

      createApp(App).use(router).mount('#app')
    </script>
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>
