<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tailon Console</title>
<!-- Tailwind (CDN build) -->
<script src="https://cdn.tailwindcss.com"></script>
<script>
// minimal dark palette tweaks
tailwind.config = {
theme: {
extend: {
colors: {
brand: {
50: '#eef2ff', 100: '#e0e7ff', 600: '#4f46e5', 700: '#4338ca',
},
},
},
},
darkMode: 'media',
}
</script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&display=swap" />
<link rel="stylesheet" href="./ds/styles.css" />
<style>
:root {
--app-sidebar-width: 330px;
}

body {
min-height: 100vh;
background: radial-gradient(120% 120% at 10% 0%, rgba(86, 102, 245, 0.12), transparent 45%),
linear-gradient(180deg, rgba(255, 122, 89, 0.06) 0%, transparent 35%),
var(--color-background);
}

.app-shell {
min-height: 100vh;
display: grid;
grid-template-columns: var(--app-sidebar-width) minmax(0, 1fr);
background: radial-gradient(80% 120% at 120% 0%, rgba(86, 102, 245, 0.1), transparent 50%),
var(--color-background);
}

@media (max-width: 1024px) {
.app-shell {
grid-template-columns: 1fr;
}
}

.app-sidebar {
background: linear-gradient(165deg, rgba(86, 102, 245, 0.16), rgba(86, 102, 245, 0.04)),
var(--color-surface);
border-right: 1px solid var(--color-border-subtle);
padding: 1.5rem 1.25rem 1.25rem;
display: flex;
flex-direction: column;
gap: 1rem;
}

@media (max-width: 1024px) {
.app-sidebar {
border-right: none;
border-bottom: 1px solid var(--color-border-subtle);
}
}

.app-brand {
display: flex;
align-items: center;
gap: 0.75rem;
}

.app-brand__icon {
width: 46px;
height: 46px;
border-radius: 16px;
display: grid;
place-items: center;
font-weight: 800;
color: #fff;
background: linear-gradient(135deg, var(--color-brand-500), var(--color-brand-700));
box-shadow: var(--shadow-md);
}

.app-brand__title {
margin: 0;
font-weight: 700;
letter-spacing: -0.01em;
}

.app-brand__subtitle {
margin: 0;
color: var(--color-text-muted);
font-size: 0.95rem;
}

.app-card {
background: var(--color-surface);
border: 1px solid var(--color-border-subtle);
border-radius: var(--radius-lg);
box-shadow: var(--shadow-sm);
padding: 1rem 1.15rem;
display: flex;
flex-direction: column;
gap: 0.8rem;
}

.app-card__title {
font-weight: 600;
}

.app-description {
color: var(--color-text-muted);
font-size: 0.95rem;
margin: 0;
}

.app-section__header {
display: flex;
align-items: center;
justify-content: space-between;
text-transform: uppercase;
letter-spacing: 0.08em;
font-size: 0.82rem;
color: var(--color-text-muted);
}

.settings-grid {
display: grid;
grid-template-columns: 1fr;
gap: 0.75rem;
}

@media (min-width: 760px) {
.settings-grid.settings-grid--split {
grid-template-columns: 1.1fr 0.9fr;
}
}

.queue-list {
display: flex;
flex-direction: column;
gap: 0.35rem;
}

.queue-item {
display: flex;
align-items: center;
gap: 0.65rem;
padding: 0.65rem 0.75rem;
border-radius: var(--radius-md);
border: 1px solid transparent;
cursor: pointer;
transition: background-color 0.15s ease, border-color 0.15s ease, transform 0.1s ease;
}

.queue-item:hover {
background-color: var(--color-surface-muted);
border-color: var(--color-border-subtle);
}

.queue-item.is-active {
border-color: rgba(86, 102, 245, 0.4);
background-color: rgba(86, 102, 245, 0.12);
box-shadow: var(--shadow-sm);
}

.queue-item__name {
flex: 1;
min-width: 0;
font-weight: 600;
}

.queue-item__actions {
display: flex;
gap: 0.4rem;
}

.app-footer {
color: var(--color-text-muted);
font-size: 0.85rem;
padding-top: 0.75rem;
border-top: 1px solid var(--color-border-subtle);
}

.app-main {
padding: 1.5rem;
}

.app-main__inner {
max-width: 1200px;
margin: 0 auto;
display: flex;
flex-direction: column;
gap: 1.25rem;
}

.app-hero {
background: linear-gradient(135deg, rgba(86, 102, 245, 0.16), rgba(255, 122, 89, 0.12));
border: 1px solid var(--color-border-subtle);
border-radius: var(--radius-lg);
padding: 1.2rem 1.4rem;
box-shadow: var(--shadow-md);
display: flex;
flex-wrap: wrap;
align-items: center;
justify-content: space-between;
gap: 0.75rem;
}

.app-hero__meta {
display: flex;
align-items: center;
gap: 0.75rem;
}

.status-pill {
display: inline-flex;
align-items: center;
gap: 0.35rem;
padding: 0.35rem 0.7rem;
border-radius: 999px;
background: rgba(86, 102, 245, 0.12);
color: var(--color-brand-700);
font-weight: 700;
font-size: 0.95rem;
}

.status-pill.is-live {
background: rgba(22, 163, 74, 0.16);
color: var(--color-success);
}

.small-label {
text-transform: uppercase;
letter-spacing: 0.08em;
font-size: 0.82rem;
color: var(--color-text-muted);
}

.panel-grid {
display: grid;
grid-template-columns: minmax(0, 360px) minmax(0, 1fr);
gap: 1rem;
align-items: start;
}

@media (max-width: 1100px) {
.panel-grid {
grid-template-columns: 1fr;
}
}

.card-muted {
background: var(--color-surface);
border: 1px solid var(--color-border-subtle);
border-radius: var(--radius-lg);
padding: 1.1rem 1.15rem;
box-shadow: var(--shadow-sm);
display: flex;
flex-direction: column;
gap: 0.75rem;
}

.code-block {
background: #0b1220;
color: var(--color-text-inverse);
border-radius: var(--radius-md);
padding: 1rem 1.05rem;
font-size: 0.9rem;
box-shadow: var(--shadow-sm);
}

.message-board {
border: 1px solid var(--color-border-subtle);
border-radius: var(--radius-lg);
background: var(--color-surface);
box-shadow: var(--shadow-sm);
display: flex;
flex-direction: column;
min-height: 420px;
}

.message-board__meta {
display: flex;
align-items: center;
justify-content: space-between;
padding: 0.95rem 1.05rem;
border-bottom: 1px solid var(--color-border-subtle);
}

.message-board__list {
list-style: none;
margin: 0;
padding: 0;
max-height: 520px;
overflow: auto;
}

.message-board__list li {
padding: 0.9rem 1.05rem;
border-bottom: 1px solid var(--color-border-subtle);
}

.message-board__list pre {
margin: 0;
}
</style>
	<!-- Vue 3 + Router (ESM via CDN) -->
	<!-- Import Map to resolve bare specifiers -->
	<script type="importmap">
		{
			"imports": {
				"vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
				"vue-router": "https://unpkg.com/vue-router@4/dist/vue-router.esm-browser.js",
				"@vue/devtools-api": "https://unpkg.com/@vue/devtools-api@6.5.0/lib/esm/index.js"
			}
		}
	</script>
	<script type="module">
		import { createApp, reactive, ref, computed, onMounted, watch } from 'vue'
		import { createRouter, createWebHashHistory, useRouter, useRoute } from 'vue-router'

		// --- Simple global store ---
		const store = reactive({
			baseUrl: 'http://localhost:8080',
			extraHeaderName: localStorage.getItem('tailon.headerName') || '', // e.g., 'X-Auth'
			extraHeaderValue: localStorage.getItem('tailon.headerValue') || '',
			queues: [],
			loadingQueues: false,
			selectedQueue: null,
			// Live stream state
			live: {
				controller: null,
				running: false,
				lines: [], // parsed JSON lines
				raw: '',   // raw text buffer (debug)
				error: '',
			},
		})

		// --- HTTP helpers ---
		function headersJSON() {
			const h = { 'Accept': 'application/json', 'Content-Type': 'application/json' }
			if (store.extraHeaderName && store.extraHeaderValue) h[store.extraHeaderName] = store.extraHeaderValue
			return h
		}
		function headersAny(accept = '*/*') {
			const h = { 'Accept': accept }
			if (store.extraHeaderName && store.extraHeaderValue) h[store.extraHeaderName] = store.extraHeaderValue
			return h
		}
		async function httpGet(path, accept = 'application/json') {
			const res = await fetch(`${store.baseUrl}${path}`, { headers: headersAny(accept) })
			if (!res.ok) throw new Error(`GET ${path} → ${res.status}`)
			if (accept === 'application/json') return res.json()
			return res.text()
		}
		async function httpPost(path, body, contentType = 'application/json') {
			const headers = headersAny('application/json')
			headers['Content-Type'] = contentType
			const res = await fetch(`${store.baseUrl}${path}`, { method: 'POST', headers, body })
			if (!res.ok) throw new Error(`POST ${path} → ${res.status}`)
			const ct = res.headers.get('content-type') || ''
			return ct.includes('application/json') ? res.json() : res.text()
		}
		async function httpDelete(path) {
			const res = await fetch(`${store.baseUrl}${path}`, { method: 'DELETE', headers: headersAny('application/json') })
			if (!res.ok) throw new Error(`DELETE ${path} → ${res.status}`)
			const ct = res.headers.get('content-type') || ''
			return ct.includes('application/json') ? res.json() : res.text()
		}

		// --- API wrappers (per OpenAPI) ---
		async function listQueues() {
			store.loadingQueues = true
			try {
				const data = await httpGet('/v1/queues') // array<string>
				store.queues = Array.isArray(data) ? data : []
			} finally {
				store.loadingQueues = false
			}
		}
		async function createQueue(name) {
			await httpPost('/v1/queues', JSON.stringify({ name }))
			await listQueues()
		}
		async function deleteQueue(id) {
			await httpDelete(`/v1/queues/${encodeURIComponent(id)}`)
			if (store.selectedQueue === id) store.selectedQueue = null
			await listQueues()
		}

		// --- Streaming read (JSONL) ---
		async function readJSONLStream(queueId, { onLine, maxLines = Infinity, timeoutMs = 30000 } = {}) {
			// Abort any previous live
			if (store.live.controller) {
				try { store.live.controller.abort() } catch {}
			}
			store.live.controller = new AbortController()
			const { signal } = store.live.controller
			const url = `${store.baseUrl}/v1/queues/${encodeURIComponent(queueId)}:read`
			const res = await fetch(url, { headers: headersAny('*/*'), signal })
			if (!res.ok) throw new Error(`READ ${url} → ${res.status}`)

			const reader = res.body.getReader()
			const decoder = new TextDecoder()
			let buffer = ''
			let count = 0
			let timer
			const resetTimer = () => {
				if (timeoutMs !== Infinity) {
					if (timer) clearTimeout(timer)
					timer = setTimeout(() => {
						try { store.live.controller.abort() } catch {}
					}, timeoutMs)
				}
			}
			resetTimer()

			try {
				while (true) {
					const { value, done } = await reader.read()
					if (done) break
					resetTimer()
					buffer += decoder.decode(value, { stream: true })
					let idx
					while ((idx = buffer.indexOf('\n')) >= 0) {
						const line = buffer.slice(0, idx)
						buffer = buffer.slice(idx + 1)
						if (line.trim().length === 0) continue
						count++
						try {
							const obj = JSON.parse(line)
							onLine && onLine(obj, line)
						} catch (e) {
							// Non-JSON line; pass raw
							onLine && onLine({ _raw: line }, line)
						}
						if (count >= maxLines) {
							try { store.live.controller.abort() } catch {}
							return
						}
					}
				}
			} finally {
				if (timer) clearTimeout(timer)
			}
		}

		// --- Write (single JSON message) ---
		async function writeJSONLine(queueId, jsonText, contentType = 'application/json') {
			// Append a newline to respect JSONL contract
			const body = contentType === 'application/json' ? (jsonText.trim() + '\n') : jsonText
			return httpPost(`/v1/queues/${encodeURIComponent(queueId)}:write`, body, contentType)
		}

		// --- Components ---
		const SettingsBar = {
			name: 'SettingsBar',
			setup() {
				const url = ref(store.baseUrl)
				const headerName = ref(store.extraHeaderName)
				const headerValue = ref(store.extraHeaderValue)
				function save() {
					store.baseUrl = url.value.trim().replace(/\/$/, '')
					store.extraHeaderName = headerName.value.trim()
					store.extraHeaderValue = headerValue.value.trim()
					localStorage.setItem('tailon.baseUrl', store.baseUrl)
					localStorage.setItem('tailon.headerName', store.extraHeaderName)
					localStorage.setItem('tailon.headerValue', store.extraHeaderValue)
				}
				function testAuth() {
					httpGet('/me').then(() => alert('Auth OK /me')).catch(e => alert('Auth fallo: ' + e.message))
                        }
                        return { url, headerName, headerValue, save, testAuth }
                },
                template: `
          <div class="app-card">
            <div class="space-y-1">
              <p class="small-label">Conexión API</p>
              <div class="app-card__title">Base URL y headers</div>
              <p class="app-description">Define el endpoint de Tailon y los headers opcionales que deban acompañar cada petición.</p>
            </div>
            <div class="settings-grid">
              <div class="flex flex-col gap-2">
                <label class="hc-form-label">Base URL</label>
                <input v-model="url" class="hc-input" placeholder="https://tailon.hola.cloud" />
              </div>
              <div class="settings-grid settings-grid--split">
                <div class="flex flex-col gap-2">
                  <label class="hc-form-label">Header</label>
                  <input v-model="headerName" class="hc-input" placeholder="X-Auth (opcional)" />
                </div>
                <div class="flex flex-col gap-2">
                  <label class="hc-form-label">Valor</label>
                  <input v-model="headerValue" class="hc-input" placeholder="Token o API key" />
                </div>
              </div>
            </div>
            <div class="flex flex-wrap gap-2 justify-end">
              <button @click="save" class="hc-button hc-btn-secondary px-4 py-2">Guardar</button>
              <button @click="testAuth" class="hc-button hc-btn-primary px-4 py-2">Probar /me</button>
            </div>
          </div>
        `
                }

		const Sidebar = {
			name: 'Sidebar',
			components: { SettingsBar },
			setup() {
				const newQueue = ref('')
				const creating = ref(false)
				const router = useRouter()

				function select(q) {
					store.selectedQueue = q
					router.push({ name: 'queue', params: { id: q } })
				}

				async function create() {
					if (!newQueue.value.trim()) return
					creating.value = true
					try {
						await createQueue(newQueue.value.trim())
						newQueue.value = ''
					} catch (e) {
						alert('No se pudo crear la cola: ' + e.message)
					} finally {
						creating.value = false
					}
                                }

                                onMounted(listQueues)

                                return { store, newQueue, creating, listQueues, create, select, deleteQueue }
                        },
                        template: `
          <aside class="app-sidebar">
            <div class="app-brand">
              <div class="app-brand__icon">HC</div>
              <div>
                <p class="app-brand__title">Tailon Console</p>
                <p class="app-brand__subtitle">Administra colas y eventos</p>
              </div>
            </div>

            <SettingsBar />

            <div class="app-card">
              <div>
                <div class="app-card__title">Nueva cola</div>
                <p class="app-description">Organiza los mensajes en colas independientes.</p>
              </div>
              <div class="settings-grid settings-grid--split">
                <div class="flex flex-col gap-2">
                  <label class="hc-form-label">Nombre</label>
                  <input v-model="newQueue" placeholder="Nombre de la cola" class="hc-input" />
                </div>
                <div class="flex flex-col gap-2 justify-end">
                  <button @click="create" :disabled="creating" class="hc-button hc-btn-primary w-full py-2">Nueva cola</button>
                </div>
              </div>
            </div>

            <div class="app-card">
              <div class="app-section__header">
                <span>Colas</span>
                <button @click="listQueues" class="hc-button hc-btn-subtle px-3 py-2 text-sm">Refrescar</button>
              </div>
              <p class="app-description">Explora y gestiona las colas activas.</p>
              <div class="queue-list">
                <div v-if="store.loadingQueues" class="app-description">Cargando…</div>
                <div v-else-if="!store.queues.length" class="app-description">No hay colas aún.</div>
                <div v-for="q in store.queues" :key="q" class="queue-item" :class="{ 'is-active': store.selectedQueue === q }" @click="select(q)">
                  <span class="queue-item__name truncate">{{ q }}</span>
                  <div class="queue-item__actions">
                    <button title="Eliminar" @click.stop="deleteQueue(q).catch(e=>alert('Error al eliminar: '+e.message))" class="hc-button hc-btn-subtle text-xs px-2 py-1">×</button>
                  </div>
                </div>
              </div>
            </div>

            <footer class="app-footer">
              Tailon Console — Hola Cloud
            </footer>
          </aside>
        `
                }

                const Home = {
                        name: 'Home',
                        template: `
          <div class="app-main__inner">
            <div class="app-hero">
              <div>
                <p class="small-label">Hola Cloud · Tailon</p>
                <h1 class="hc-heading-3">Bienvenido a la consola de colas</h1>
                <p class="app-description">Selecciona una cola en el panel lateral o crea una nueva para empezar a leer y enviar mensajes JSON.</p>
              </div>
              <div class="flex gap-2">
                <div class="status-pill">Listo para conectar</div>
              </div>
            </div>
            <div class="panel-grid">
              <div class="card-muted">
                <p class="small-label">Primeros pasos</p>
                <div class="app-card__title">Configura la URL del API</div>
                <p class="app-description">Asegúrate de que la consola apunta al endpoint correcto y añade headers de autenticación si son necesarios.</p>
                <p class="hc-helper-text">La configuración se almacena en tu navegador para reutilizarla en sesiones futuras.</p>
              </div>
              <div class="card-muted">
                <p class="small-label">Crea tu primera cola</p>
                <div class="app-card__title">Organiza los mensajes</div>
                <p class="app-description">Lanza una cola nueva desde el panel lateral para agrupar eventos y empezar a consumirlos en streaming.</p>
                <p class="hc-helper-text">Puedes refrescar la lista de colas en cualquier momento.</p>
              </div>
            </div>
          </div>
        `
                }

		const QueueView = {
			name: 'QueueView',
			setup() {
				const route = useRoute()
				const queueId = computed(() => route.params.id)
				const n = ref(10)
				const timeoutMs = ref(30000)
				const sending = ref(false)
				const contentType = ref('application/json')
				const newMessage = ref('{"hello":"world"}')

				function resetBuffer() {
					store.live.lines = []
					store.live.raw = ''
					store.live.error = ''
				}

				async function readN() {
					resetBuffer()
					try {
						await readJSONLStream(queueId.value, {
							maxLines: Number(n.value) || 1,
							timeoutMs: Number(timeoutMs.value) || 30000,
							onLine(obj, raw) {
								store.live.lines.unshift(obj) // newest first
								store.live.raw += raw + '\n'
							}
						})
					} catch (e) {
						store.live.error = e.message
					}
				}

				async function toggleLive() {
					if (store.live.running) {
						try { store.live.controller?.abort() } catch {}
						store.live.running = false
						return
					}
					resetBuffer()
					store.live.running = true
					try {
						await readJSONLStream(queueId.value, {
							maxLines: Infinity,
							timeoutMs: Infinity,
							onLine(obj, raw) {
								store.live.lines.unshift(obj)
								store.live.raw += raw + '\n'
							}
						})
					} catch (e) {
						store.live.error = e.message
					} finally {
						store.live.running = false
					}
				}

				async function sendMessage() {
					sending.value = true
					try {
						await writeJSONLine(queueId.value, newMessage.value, contentType.value)
					} catch (e) {
						alert('Error al enviar: ' + e.message)
					} finally {
						sending.value = false
					}
				}

				watch(queueId, (v) => {
					store.selectedQueue = v
					resetBuffer()
				}, { immediate: true })

                                const curlCmd = computed(() => {
                                        const url = `${store.baseUrl}/v1/queues/${encodeURIComponent(queueId.value)}:read`
                                        const header = (store.extraHeaderName && store.extraHeaderValue) ? ` -H "${store.extraHeaderName}: ${store.extraHeaderValue}"` : ''
                                        return `curl -N -s${header} "${url}"`
                                })

                                return { store, queueId, n, timeoutMs, newMessage, contentType, readN, toggleLive, sendMessage, curlCmd, resetBuffer }
                        },
                        template: `
          <div class="app-main__inner">
            <div class="app-hero">
              <div>
                <p class="small-label">Cola activa</p>
                <h2 class="hc-heading-3">Cola: <span class="hc-mono">{{ queueId }}</span></h2>
                <p class="app-description">Lectura en streaming (JSON Lines) y envío de mensajes.</p>
              </div>
              <div class="app-hero__meta">
                <div :class="['status-pill', store.live.running ? 'is-live' : '']">
                  <span v-if="store.live.running">LIVE activo</span>
                  <span v-else>En pausa</span>
                </div>
                <button @click="resetBuffer" class="hc-button hc-btn-secondary px-4 py-2">Limpiar</button>
                <button @click="toggleLive" :class="['hc-button', 'px-4', 'py-2', store.live.running ? 'hc-btn-danger' : 'hc-btn-primary']">
                  {{ store.live.running ? 'Parar LIVE' : 'LIVE (seguir)' }}
                </button>
              </div>
            </div>

            <div class="panel-grid">
              <section class="space-y-4">
                <div class="card-muted">
                  <p class="small-label">Obtener mensajes</p>
                  <div class="app-card__title">Lectura puntual</div>
                  <div class="settings-grid settings-grid--split">
                    <div class="flex flex-col gap-2">
                      <label class="hc-form-label">Siguientes N</label>
                      <input v-model.number="n" type="number" min="1" class="hc-input" />
                    </div>
                    <div class="flex flex-col gap-2">
                      <label class="hc-form-label">Timeout (ms)</label>
                      <input v-model.number="timeoutMs" type="number" min="0" class="hc-input" />
                    </div>
                  </div>
                  <div class="flex justify-end gap-2 items-center">
                    <p v-if="store.live.error" class="hc-error-text text-sm">{{ store.live.error }}</p>
                    <button @click="readN" class="hc-button hc-btn-secondary px-4 py-2">Leer</button>
                  </div>
                </div>

                <div class="card-muted">
                  <p class="small-label">Crear mensaje</p>
                  <div class="app-card__title">Publica en la cola</div>
                  <div class="settings-grid settings-grid--split">
                    <div class="flex flex-col gap-2">
                      <label class="hc-form-label">Content-Type</label>
                      <select v-model="contentType" class="hc-input">
                        <option>application/json</option>
                        <option>text/plain</option>
                      </select>
                    </div>
                    <div class="flex flex-col gap-2 justify-end">
                      <button @click="sendMessage" :disabled="sending" class="hc-button hc-btn-primary px-4 py-2 w-full">Enviar</button>
                    </div>
                  </div>
                  <textarea v-model="newMessage" rows="6" spellcheck="false" class="hc-input hc-mono" style="min-height: 160px; resize: vertical;"></textarea>
                  <p class="hc-helper-text">Se envía como una sola línea (JSONL). Si usas <em>application/json</em>, se añade un <code>\n</code> al final.</p>
                </div>

                <div class="card-muted">
                  <p class="small-label">cURL (stream)</p>
                  <div class="app-card__title">Replica la lectura en terminal</div>
                  <pre class="code-block overflow-auto"><code>{{ curlCmd }}</code></pre>
                </div>
              </section>

              <section class="message-board">
                <div class="message-board__meta">
                  <div>
                    <p class="small-label">Mensajes recibidos</p>
                    <div class="app-card__title">{{ store.live.lines.length }} elementos</div>
                  </div>
                  <div :class="['status-pill', store.live.running ? 'is-live' : '']">Buffer {{ store.live.lines.length }}</div>
                </div>
                <ul class="message-board__list">
                  <li v-for="(m, i) in store.live.lines" :key="i">
                    <pre class="text-sm hc-mono whitespace-pre-wrap">{{ JSON.stringify(m, null, 2) }}</pre>
                  </li>
                  <li v-if="!store.live.lines.length" class="app-description text-center py-6">Sin datos aún. Empieza una lectura o activa LIVE.</li>
                </ul>
              </section>
            </div>
          </div>
        `
                }

		// --- Router ---
		const routes = [
			{ path: '/', name: 'home', component: Home },
			{ path: '/queue/:id', name: 'queue', component: QueueView, props: true },
		]
		const router = createRouter({ history: createWebHashHistory(), routes })

		// --- Root App ---
		const App = {
			name: 'App',
			components: { Sidebar },
			setup() {
				onMounted(() => {
					// pick first queue automatically on load (optional)
					listQueues().then(() => {
						if (store.queues.length && router.currentRoute.value.name === 'home') {
							const q = store.queues[0]
							store.selectedQueue = q
							router.replace({ name: 'queue', params: { id: q } })
						}
					})
                                })
                                return { store }
                        },
                        template: `
          <div class="app-shell">
            <Sidebar />
            <main class="app-main">
              <router-view />
            </main>
          </div>
        `
                }

		createApp(App).use(router).mount('#app')
	</script>
</head>
<body>
<div id="app"></div>
</body>
</html>
