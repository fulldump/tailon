<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Tailon Console</title>
    <link rel="icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./css/hc-tailon.css" />
    <script type="importmap">
      {
        "imports": {
          "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
          "vue-router": "https://unpkg.com/vue-router@4/dist/vue-router.esm-browser.js",
          "@vue/devtools-api": "https://unpkg.com/@vue/devtools-api@6.5.0/lib/esm/index.js"
        }
      }
    </script>
    <script type="module">
      import { createApp, reactive, ref, computed, onMounted, watch } from 'vue'
      import { createRouter, createWebHashHistory, useRouter, useRoute } from 'vue-router'

      const storedBaseUrl = (localStorage.getItem('tailon.baseUrl') || 'http://localhost:8080').replace(/\/$/, '')
      const store = reactive({
        baseUrl: storedBaseUrl,
        extraHeaderName: localStorage.getItem('tailon.headerName') || '',
        extraHeaderValue: localStorage.getItem('tailon.headerValue') || '',
        queues: [],
        loadingQueues: false,
        selectedQueue: null,
        live: {
          controller: null,
          running: false,
          lines: [],
          raw: '',
          error: '',
        },
      })

      function headersJSON() {
        const h = { Accept: 'application/json', 'Content-Type': 'application/json' }
        if (store.extraHeaderName && store.extraHeaderValue) h[store.extraHeaderName] = store.extraHeaderValue
        return h
      }

      function headersAny(accept = '*/*') {
        const h = { Accept: accept }
        if (store.extraHeaderName && store.extraHeaderValue) h[store.extraHeaderName] = store.extraHeaderValue
        return h
      }

      async function httpGet(path, accept = 'application/json') {
        const res = await fetch(`${store.baseUrl}${path}`, { headers: headersAny(accept) })
        if (!res.ok) throw new Error(`GET ${path} → ${res.status}`)
        if (accept === 'application/json') return res.json()
        return res.text()
      }

      async function httpPost(path, body, contentType = 'application/json') {
        const headers = headersAny('application/json')
        headers['Content-Type'] = contentType
        const res = await fetch(`${store.baseUrl}${path}`, { method: 'POST', headers, body })
        if (!res.ok) throw new Error(`POST ${path} → ${res.status}`)
        const ct = res.headers.get('content-type') || ''
        return ct.includes('application/json') ? res.json() : res.text()
      }

      async function httpDelete(path) {
        const res = await fetch(`${store.baseUrl}${path}`, { method: 'DELETE', headers: headersAny('application/json') })
        if (!res.ok) throw new Error(`DELETE ${path} → ${res.status}`)
        const ct = res.headers.get('content-type') || ''
        return ct.includes('application/json') ? res.json() : res.text()
      }

      async function listQueues() {
        store.loadingQueues = true
        try {
          const data = await httpGet('/v1/queues')
          store.queues = Array.isArray(data) ? data : []
        } finally {
          store.loadingQueues = false
        }
      }

      async function createQueue(name) {
        await httpPost('/v1/queues', JSON.stringify({ name }))
        await listQueues()
      }

      async function deleteQueue(id) {
        await httpDelete(`/v1/queues/${encodeURIComponent(id)}`)
        if (store.selectedQueue === id) store.selectedQueue = null
        await listQueues()
      }

      async function readJSONLStream(queueId, { onLine, maxLines = Infinity, timeoutMs = 30000 } = {}) {
        if (store.live.controller) {
          try {
            store.live.controller.abort()
          } catch (err) {
            console.warn(err)
          }
        }
        store.live.controller = new AbortController()
        const { signal } = store.live.controller
        const url = `${store.baseUrl}/v1/queues/${encodeURIComponent(queueId)}:read`
        const res = await fetch(url, { headers: headersAny('*/*'), signal })
        if (!res.ok) throw new Error(`READ ${url} → ${res.status}`)

        const reader = res.body.getReader()
        const decoder = new TextDecoder()
        let buffer = ''
        let count = 0
        let timer

        const resetTimer = () => {
          if (timeoutMs === Infinity) return
          if (timer) clearTimeout(timer)
          timer = setTimeout(() => {
            try {
              store.live.controller.abort()
            } catch (err) {
              console.warn(err)
            }
          }, timeoutMs)
        }

        resetTimer()

        try {
          while (true) {
            const { value, done } = await reader.read()
            if (done) break
            resetTimer()
            buffer += decoder.decode(value, { stream: true })
            let idx
            while ((idx = buffer.indexOf('\n')) >= 0) {
              const line = buffer.slice(0, idx)
              buffer = buffer.slice(idx + 1)
              if (!line.trim()) continue
              count += 1
              try {
                const obj = JSON.parse(line)
                onLine && onLine(obj, line)
              } catch (err) {
                onLine && onLine({ _raw: line }, line)
              }
              if (count >= maxLines) {
                try {
                  store.live.controller.abort()
                } catch (err) {
                  console.warn(err)
                }
                return
              }
            }
          }
        } finally {
          if (timer) clearTimeout(timer)
        }
      }

      async function writeJSONLine(queueId, jsonText, contentType = 'application/json') {
        const body = contentType === 'application/json' ? `${jsonText.trim()}\n` : jsonText
        return httpPost(`/v1/queues/${encodeURIComponent(queueId)}:write`, body, contentType)
      }

      const SettingsBar = {
        name: 'SettingsBar',
        setup() {
          const url = ref(store.baseUrl)
          const headerName = ref(store.extraHeaderName)
          const headerValue = ref(store.extraHeaderValue)

          function save() {
            store.baseUrl = url.value.trim().replace(/\/$/, '')
            store.extraHeaderName = headerName.value.trim()
            store.extraHeaderValue = headerValue.value.trim()
            localStorage.setItem('tailon.baseUrl', store.baseUrl)
            localStorage.setItem('tailon.headerName', store.extraHeaderName)
            localStorage.setItem('tailon.headerValue', store.extraHeaderValue)
          }

          function testAuth() {
            httpGet('/me')
              .then(() => alert('Autenticación correcta: /me'))
              .catch((e) => alert('Fallo de autenticación: ' + e.message))
          }

          return { url, headerName, headerValue, save, testAuth }
        },
        template: `
          <section class="hc-panel">
            <header class="hc-panel__header">
              <p class="hc-panel__kicker">Conexión</p>
              <h2 class="hc-panel__title">Configuración de API</h2>
              <p class="hc-panel__hint">Define la URL base y los encabezados adicionales para autenticar tus peticiones.</p>
            </header>
            <form class="hc-form-stack" @submit.prevent="save">
              <label class="hc-input-wrapper">
                <span class="hc-form-label">Base URL</span>
                <input v-model="url" class="hc-input" placeholder="https://tailon.hola.cloud" />
              </label>
              <div class="hc-field-row">
                <label class="hc-input-wrapper hc-field-grow">
                  <span class="hc-form-label">Header</span>
                  <input v-model="headerName" class="hc-input" placeholder="X-Auth (opcional)" />
                </label>
                <label class="hc-input-wrapper hc-field-grow">
                  <span class="hc-form-label">Valor</span>
                  <input v-model="headerValue" class="hc-input" placeholder="Valor del header" />
                </label>
              </div>
              <div class="hc-panel__actions">
                <button type="submit" class="hc-button hc-btn-primary">Aplicar cambios</button>
                <button type="button" class="hc-button hc-btn-secondary" @click="testAuth">Probar /me</button>
              </div>
            </form>
          </section>
        `,
      }

      const Sidebar = {
        name: 'Sidebar',
        components: { SettingsBar },
        setup() {
          const router = useRouter()
          const newQueue = ref('')
          const creating = ref(false)

          function select(queue) {
            store.selectedQueue = queue
            router.push({ name: 'queue', params: { id: queue } })
          }

          async function create() {
            if (!newQueue.value.trim()) return
            creating.value = true
            try {
              await createQueue(newQueue.value.trim())
              newQueue.value = ''
            } catch (e) {
              alert('No se pudo crear la cola: ' + e.message)
            } finally {
              creating.value = false
            }
          }

          async function remove(queue) {
            try {
              await deleteQueue(queue)
            } catch (e) {
              alert('Error al eliminar la cola: ' + e.message)
            }
          }

          onMounted(() => {
            if (!store.queues.length) listQueues()
          })

          return { store, newQueue, creating, select, create, remove, listQueues }
        },
        template: `
          <aside class="hc-shell__sidebar">
            <div class="hc-sidebar__brand">
              <div class="hc-sidebar__badge">Tailon</div>
              <div>
                <h1 class="hc-sidebar__title">Console</h1>
                <p class="hc-sidebar__subtitle">Gestión de colas en tiempo real</p>
              </div>
            </div>
            <SettingsBar />
            <section class="hc-panel hc-panel--queues">
              <header class="hc-panel__header">
                <p class="hc-panel__kicker">Colas</p>
                <h2 class="hc-panel__title">Recursos disponibles</h2>
                <p class="hc-panel__hint">Refresca para sincronizar con el servidor.</p>
              </header>
              <form class="hc-form-stack" @submit.prevent="create">
                <div class="hc-field-row">
                  <label class="hc-input-wrapper hc-field-grow">
                    <span class="hc-form-label">Nombre</span>
                    <input v-model="newQueue" class="hc-input" placeholder="logs-app" />
                  </label>
                  <button type="submit" class="hc-button hc-btn-primary" :disabled="creating">Crear</button>
                </div>
              </form>
              <div class="hc-panel__actions">
                <button type="button" class="hc-button hc-btn-subtle" @click="listQueues">Refrescar</button>
                <span class="hc-helper-text" v-if="store.loadingQueues">Actualizando…</span>
              </div>
              <div class="hc-queue-list-wrapper">
                <p v-if="store.loadingQueues && !store.queues.length" class="hc-list__empty">Cargando colas…</p>
                <p v-else-if="!store.loadingQueues && !store.queues.length" class="hc-list__empty">No hay colas aún. Crea la primera para empezar.</p>
                <ul v-else class="hc-queue-list">
                  <li v-for="q in store.queues" :key="q">
                    <div class="hc-queue-item" :class="{ 'is-active': store.selectedQueue === q }">
                      <button type="button" class="hc-queue-item__main" @click="select(q)">
                        <span class="hc-queue-item__name">{{ q }}</span>
                      </button>
                      <button type="button" class="hc-icon-button" title="Eliminar cola" @click.stop="remove(q)">
                        <span aria-hidden="true">&times;</span>
                      </button>
                    </div>
                  </li>
                </ul>
              </div>
            </section>
            <footer class="hc-sidebar__footer">
              <span class="hc-sidebar__tagline">Tailon Console · Hola Cloud</span>
              <span class="hc-sidebar__version">Vue 3 · Streaming JSONL</span>
            </footer>
          </aside>
        `,
      }

      const Home = {
        name: 'Home',
        template: `
          <div class="hc-main">
            <section class="hc-card hc-card--welcome">
              <span class="hc-badge">Tailon Console</span>
              <h1 class="hc-heading-2">Observa tus colas en tiempo real</h1>
              <p class="hc-body">Selecciona una cola en la barra lateral o crea una nueva para comenzar a publicar y consumir mensajes.</p>
              <ul class="hc-list-disc">
                <li>Administra la configuración de conexión y cabeceras personalizadas.</li>
                <li>Lee mensajes bajo demanda o mantén un stream LIVE continuo.</li>
                <li>Comparte la URL <span class="hc-mono">curl</span> con tu equipo para depurar.</li>
              </ul>
            </section>
          </div>
        `,
      }

      const QueueView = {
        name: 'QueueView',
        setup() {
          const route = useRoute()
          const queueId = computed(() => route.params.id)
          const n = ref(10)
          const timeoutMs = ref(30000)
          const sending = ref(false)
          const contentType = ref('application/json')
          const newMessage = ref('{"hello":"world"}')

          function resetBuffer() {
            store.live.lines = []
            store.live.raw = ''
            store.live.error = ''
          }

          async function readN() {
            resetBuffer()
            try {
              await readJSONLStream(queueId.value, {
                maxLines: Number(n.value) || 1,
                timeoutMs: Number(timeoutMs.value) || 30000,
                onLine(obj, raw) {
                  store.live.lines.unshift(obj)
                  store.live.raw += `${raw}\n`
                },
              })
            } catch (e) {
              store.live.error = e.message
            }
          }

          async function toggleLive() {
            if (store.live.running) {
              try {
                store.live.controller?.abort()
              } catch (err) {
                console.warn(err)
              }
              store.live.running = false
              return
            }
            resetBuffer()
            store.live.running = true
            try {
              await readJSONLStream(queueId.value, {
                maxLines: Infinity,
                timeoutMs: Infinity,
                onLine(obj, raw) {
                  store.live.lines.unshift(obj)
                  store.live.raw += `${raw}\n`
                },
              })
            } catch (e) {
              store.live.error = e.message
            } finally {
              store.live.running = false
            }
          }

          async function sendMessage() {
            sending.value = true
            try {
              await writeJSONLine(queueId.value, newMessage.value, contentType.value)
            } catch (e) {
              alert('Error al enviar: ' + e.message)
            } finally {
              sending.value = false
            }
          }

          watch(
            queueId,
            (value) => {
              store.selectedQueue = value
              resetBuffer()
            },
            { immediate: true },
          )

          const curlCmd = computed(() => {
            const url = `${store.baseUrl}/v1/queues/${encodeURIComponent(queueId.value)}:read`
            const header = store.extraHeaderName && store.extraHeaderValue ? ` -H \"${store.extraHeaderName}: ${store.extraHeaderValue}\"` : ''
            return `curl -N -s${header} \"${url}\"`
          })

          return {
            store,
            queueId,
            n,
            timeoutMs,
            newMessage,
            contentType,
            readN,
            toggleLive,
            sendMessage,
            curlCmd,
            resetBuffer,
            sending,
          }
        },
        template: `
          <div class="hc-main">
            <header class="hc-card hc-main-header">
              <div>
                <p class="hc-kicker">Cola activa</p>
                <h1 class="hc-heading-3 hc-main-title">{{ queueId }}</h1>
                <p class="hc-main-subtitle">Lectura en streaming (JSON Lines) y envío de mensajes.</p>
              </div>
              <div class="hc-header-actions">
                <button type="button" class="hc-button hc-btn-secondary" @click="resetBuffer">Limpiar</button>
                <button type="button" class="hc-button" :class="store.live.running ? 'hc-btn-danger' : 'hc-btn-primary'" @click="toggleLive">
                  {{ store.live.running ? 'Detener LIVE' : 'LIVE (seguir)' }}
                </button>
              </div>
            </header>

            <section class="hc-main-grid">
              <article class="hc-card">
                <header class="hc-card__header">
                  <h2 class="hc-card__title">Obtener mensajes</h2>
                  <p class="hc-card__subtitle">Consume mensajes de la cola bajo demanda.</p>
                </header>
                <form class="hc-form-stack" @submit.prevent="readN">
                  <div class="hc-field-row">
                    <label class="hc-input-wrapper hc-field-grow">
                      <span class="hc-form-label">Siguientes N</span>
                      <input v-model.number="n" type="number" min="1" class="hc-input" />
                    </label>
                    <label class="hc-input-wrapper hc-field-grow">
                      <span class="hc-form-label">Timeout (ms)</span>
                      <input v-model.number="timeoutMs" type="number" min="0" class="hc-input" />
                    </label>
                  </div>
                  <div class="hc-panel__actions">
                    <button type="submit" class="hc-button hc-btn-primary">Leer</button>
                    <span v-if="store.live.error" class="hc-error-text">{{ store.live.error }}</span>
                  </div>
                </form>
              </article>

              <article class="hc-card">
                <header class="hc-card__header">
                  <h2 class="hc-card__title">Crear mensaje</h2>
                  <p class="hc-card__subtitle">Publica un evento en la cola.</p>
                </header>
                <form class="hc-form-stack" @submit.prevent="sendMessage">
                  <div class="hc-field-row">
                    <label class="hc-input-wrapper hc-field-grow">
                      <span class="hc-form-label">Content-Type</span>
                      <select v-model="contentType" class="hc-input">
                        <option value="application/json">application/json</option>
                        <option value="text/plain">text/plain</option>
                      </select>
                    </label>
                    <button type="submit" class="hc-button hc-btn-secondary" :disabled="sending">Enviar</button>
                  </div>
                  <label class="hc-input-wrapper">
                    <span class="hc-form-label">Payload</span>
                    <textarea v-model="newMessage" rows="6" spellcheck="false" class="hc-textarea hc-mono"></textarea>
                  </label>
                  <p class="hc-helper-text">
                    Se envía como una única línea JSONL. Para <code class="hc-code-inline">application/json</code> se añade un salto de línea final automáticamente.
                  </p>
                </form>
              </article>

              <article class="hc-card">
                <header class="hc-card__header">
                  <h2 class="hc-card__title">cURL (stream)</h2>
                  <p class="hc-card__subtitle">Replica la lectura continua desde la terminal.</p>
                </header>
                <pre class="hc-code-block hc-mono">{{ curlCmd }}</pre>
              </article>
            </section>

            <section class="hc-card hc-log-card">
              <div class="hc-log-card__header">
                <div>
                  <h2 class="hc-card__title">Mensajes recibidos</h2>
                  <p class="hc-card__subtitle">Los más recientes aparecen al inicio.</p>
                </div>
                <span class="hc-badge">{{ store.live.lines.length }} en memoria</span>
              </div>
              <div class="hc-log-card__body">
                <template v-if="store.live.lines.length">
                  <article v-for="(m, index) in store.live.lines" :key="index" class="hc-log-entry">
                    <pre class="hc-code-block hc-code-block--surface">{{ JSON.stringify(m, null, 2) }}</pre>
                  </article>
                </template>
                <p v-else class="hc-log-empty">Sin datos aún. Ejecuta una lectura o activa LIVE.</p>
              </div>
            </section>
          </div>
        `,
      }

      const routes = [
        { path: '/', name: 'home', component: Home },
        { path: '/queue/:id', name: 'queue', component: QueueView, props: true },
      ]

      const router = createRouter({ history: createWebHashHistory(), routes })

      const App = {
        name: 'App',
        components: { Sidebar },
        setup() {
          onMounted(() => {
            listQueues().then(() => {
              if (store.queues.length && router.currentRoute.value.name === 'home') {
                const queue = store.queues[0]
                store.selectedQueue = queue
                router.replace({ name: 'queue', params: { id: queue } })
              }
            })
          })
          return { store }
        },
        template: `
          <div class="hc-shell">
            <Sidebar />
            <main class="hc-shell__main">
              <router-view />
            </main>
          </div>
        `,
      }

      createApp(App).use(router).mount('#app')
    </script>
  </head>
  <body>
    <div id="app" class="hc-shell-loading">Cargando consola…</div>
  </body>
</html>
