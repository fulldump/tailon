<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tailon Console</title>
  <link rel="icon" href="../../ds/favicon.ico" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="../../ds/styles.css" />
  <link rel="stylesheet" href="./app.css" />
  <script type="importmap">
    {
      "imports": {
        "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
        "vue-router": "https://unpkg.com/vue-router@4/dist/vue-router.esm-browser.js",
        "@vue/devtools-api": "https://unpkg.com/@vue/devtools-api@6.5.0/lib/esm/index.js"
      }
    }
  </script>
  <script type="module">
    import { createApp, reactive, ref, computed, onMounted, watch } from 'vue'
    import { createRouter, createWebHashHistory, useRouter, useRoute } from 'vue-router'

    const store = reactive({
      baseUrl: localStorage.getItem('tailon.baseUrl') || 'http://localhost:8080',
      extraHeaderName: localStorage.getItem('tailon.headerName') || '',
      extraHeaderValue: localStorage.getItem('tailon.headerValue') || '',
      queues: [],
      loadingQueues: false,
      selectedQueue: null,
      live: {
        controller: null,
        running: false,
        lines: [],
        raw: '',
        error: '',
      },
    })

    function headersJSON() {
      const h = { Accept: 'application/json', 'Content-Type': 'application/json' }
      if (store.extraHeaderName && store.extraHeaderValue) h[store.extraHeaderName] = store.extraHeaderValue
      return h
    }
    function headersAny(accept = '*/*') {
      const h = { Accept: accept }
      if (store.extraHeaderName && store.extraHeaderValue) h[store.extraHeaderName] = store.extraHeaderValue
      return h
    }
    async function httpGet(path, accept = 'application/json') {
      const res = await fetch(`${store.baseUrl}${path}`, { headers: headersAny(accept) })
      if (!res.ok) throw new Error(`GET ${path} → ${res.status}`)
      if (accept === 'application/json') return res.json()
      return res.text()
    }
    async function httpPost(path, body, contentType = 'application/json') {
      const headers = headersAny('application/json')
      headers['Content-Type'] = contentType
      const res = await fetch(`${store.baseUrl}${path}`, { method: 'POST', headers, body })
      if (!res.ok) throw new Error(`POST ${path} → ${res.status}`)
      const ct = res.headers.get('content-type') || ''
      return ct.includes('application/json') ? res.json() : res.text()
    }
    async function httpDelete(path) {
      const res = await fetch(`${store.baseUrl}${path}`, { method: 'DELETE', headers: headersAny('application/json') })
      if (!res.ok) throw new Error(`DELETE ${path} → ${res.status}`)
      const ct = res.headers.get('content-type') || ''
      return ct.includes('application/json') ? res.json() : res.text()
    }

    async function listQueues() {
      store.loadingQueues = true
      try {
        const data = await httpGet('/v1/queues')
        store.queues = Array.isArray(data) ? data : []
      } finally {
        store.loadingQueues = false
      }
    }
    async function createQueue(name) {
      await httpPost('/v1/queues', JSON.stringify({ name }))
      await listQueues()
    }
    async function deleteQueue(id) {
      await httpDelete(`/v1/queues/${encodeURIComponent(id)}`)
      if (store.selectedQueue === id) store.selectedQueue = null
      await listQueues()
    }

    async function readJSONLStream(queueId, { onLine, maxLines = Infinity, timeoutMs = 30000 } = {}) {
      if (store.live.controller) {
        try {
          store.live.controller.abort()
        } catch {}
      }
      store.live.controller = new AbortController()
      const { signal } = store.live.controller
      const url = `${store.baseUrl}/v1/queues/${encodeURIComponent(queueId)}:read`
      const res = await fetch(url, { headers: headersAny('*/*'), signal })
      if (!res.ok) throw new Error(`READ ${url} → ${res.status}`)

      const reader = res.body.getReader()
      const decoder = new TextDecoder()
      let buffer = ''
      let count = 0
      let timer
      const resetTimer = () => {
        if (timeoutMs !== Infinity) {
          if (timer) clearTimeout(timer)
          timer = setTimeout(() => {
            try {
              store.live.controller.abort()
            } catch {}
          }, timeoutMs)
        }
      }
      resetTimer()

      try {
        while (true) {
          const { value, done } = await reader.read()
          if (done) break
          resetTimer()
          buffer += decoder.decode(value, { stream: true })
          let idx
          while ((idx = buffer.indexOf('\n')) >= 0) {
            const line = buffer.slice(0, idx)
            buffer = buffer.slice(idx + 1)
            if (line.trim().length === 0) continue
            count++
            try {
              const obj = JSON.parse(line)
              onLine && onLine(obj, line)
            } catch (e) {
              onLine && onLine({ _raw: line }, line)
            }
            if (count >= maxLines) {
              try {
                store.live.controller.abort()
              } catch {}
              return
            }
          }
        }
      } finally {
        if (timer) clearTimeout(timer)
      }
    }

    async function writeJSONLine(queueId, jsonText, contentType = 'application/json') {
      const body = contentType === 'application/json' ? jsonText.trim() + '\n' : jsonText
      return httpPost(`/v1/queues/${encodeURIComponent(queueId)}:write`, body, contentType)
    }

    const SettingsBar = {
      name: 'SettingsBar',
      setup() {
        const url = ref(store.baseUrl)
        const headerName = ref(store.extraHeaderName)
        const headerValue = ref(store.extraHeaderValue)
        function save() {
          store.baseUrl = url.value.trim().replace(/\/$/, '') || 'http://localhost:8080'
          store.extraHeaderName = headerName.value.trim()
          store.extraHeaderValue = headerValue.value.trim()
          localStorage.setItem('tailon.baseUrl', store.baseUrl)
          localStorage.setItem('tailon.headerName', store.extraHeaderName)
          localStorage.setItem('tailon.headerValue', store.extraHeaderValue)
        }
        function testAuth() {
          httpGet('/me')
            .then(() => alert('Auth OK /me'))
            .catch((e) => alert('Auth fallo: ' + e.message))
        }
        return { url, headerName, headerValue, save, testAuth }
      },
      template: `
        <section class="hc-card app-card">
          <header class="app-card-header">
            <div>
              <p class="app-kicker">Conexión</p>
              <h2 class="app-card-title">Endpoint Tailon</h2>
            </div>
            <div class="app-card-actions">
              <button type="button" class="app-button app-button--ghost" @click="testAuth">Probar /me</button>
              <button type="button" class="app-button" @click="save">Guardar</button>
            </div>
          </header>
          <div class="app-card-body">
            <label class="app-field">
              <span>Base URL</span>
              <input v-model="url" class="app-input" placeholder="https://tailon.hola.cloud" />
            </label>
            <div class="app-field-grid">
              <label class="app-field">
                <span>Header opcional</span>
                <input v-model="headerName" class="app-input" placeholder="X-Auth" />
              </label>
              <label class="app-field">
                <span>Valor</span>
                <input v-model="headerValue" class="app-input" placeholder="Token o API key" />
              </label>
            </div>
            <p class="app-helper">Los ajustes se guardan en este navegador para agilizar futuras sesiones.</p>
          </div>
        </section>
      `,
    }

    const Sidebar = {
      name: 'Sidebar',
      components: { SettingsBar },
      setup() {
        const newQueue = ref('')
        const creating = ref(false)
        const router = useRouter()

        function select(q) {
          store.selectedQueue = q
          router.push({ name: 'queue', params: { id: q } })
        }

        async function create() {
          if (!newQueue.value.trim()) return
          creating.value = true
          try {
            await createQueue(newQueue.value.trim())
            newQueue.value = ''
          } catch (e) {
            alert('No se pudo crear la cola: ' + e.message)
          } finally {
            creating.value = false
          }
        }

        onMounted(listQueues)

        return { store, newQueue, creating, listQueues, create, select, deleteQueue }
      },
      template: `
        <div class="app-sidebar-content">
          <SettingsBar />
          <section class="hc-card app-card">
            <header class="app-card-header">
              <div>
                <p class="app-kicker">Colas</p>
                <h2 class="app-card-title">Gestión rápida</h2>
              </div>
              <button type="button" class="app-button app-button--ghost" @click="listQueues">Actualizar</button>
            </header>
            <div class="app-field-grid app-field-grid--compact">
              <input v-model="newQueue" class="app-input" placeholder="Nombre de la cola" />
              <button type="button" class="app-button" @click="create" :disabled="creating">
                {{ creating ? 'Creando…' : 'Nueva cola' }}
              </button>
            </div>
            <div class="app-queue-list-wrapper">
              <ul class="app-queue-list">
                <li v-if="store.loadingQueues" class="app-queue-empty">Cargando colas…</li>
                <li v-else-if="!store.queues.length" class="app-queue-empty">Aún no se registran colas.</li>
                <li v-for="q in store.queues" :key="q">
                  <div class="app-queue-item" :class="{ 'is-active': store.selectedQueue === q }">
                    <button type="button" class="app-queue-link" @click="select(q)">
                      <span class="app-queue-name">{{ q }}</span>
                      <span class="app-queue-meta" v-if="store.selectedQueue === q">Seleccionada</span>
                    </button>
                    <button
                      type="button"
                      class="app-icon-button"
                      title="Eliminar"
                      @click.stop="deleteQueue(q).catch(e => alert('Error al eliminar: ' + e.message))"
                    >
                      ×
                    </button>
                  </div>
                </li>
              </ul>
            </div>
          </section>
          <footer class="app-sidebar-footer">
            <span>Tailon Console · hola.cloud</span>
            <small>Vue 3 · Streaming JSONL</small>
          </footer>
        </div>
      `,
    }

    const Home = {
      name: 'Home',
      template: `
        <div class="app-main-content">
          <section class="hc-card app-card app-page-intro">
            <p class="app-kicker">Gestión distribuida</p>
            <h1 class="hc-heading-2">Bienvenido a Tailon Console</h1>
            <p class="app-subtitle">Selecciona una cola en el panel lateral o crea una nueva para empezar a enviar y consumir mensajes.</p>
            <ul class="app-guide-list">
              <li>Configura el endpoint y headers de autenticación desde la barra lateral.</li>
              <li>Consulta mensajes recientes o inicia el modo LIVE para observar el stream en tiempo real.</li>
              <li>Envía mensajes JSON o texto plano directamente desde la interfaz.</li>
            </ul>
          </section>
        </div>
      `,
    }

    const QueueView = {
      name: 'QueueView',
      setup() {
        const route = useRoute()
        const queueId = computed(() => route.params.id)
        const n = ref(10)
        const timeoutMs = ref(30000)
        const sending = ref(false)
        const contentType = ref('application/json')
        const newMessage = ref('{"hello":"world"}')

        function resetBuffer() {
          store.live.lines = []
          store.live.raw = ''
          store.live.error = ''
        }

        async function readN() {
          resetBuffer()
          try {
            await readJSONLStream(queueId.value, {
              maxLines: Number(n.value) || 1,
              timeoutMs: Number(timeoutMs.value) || 30000,
              onLine(obj, raw) {
                store.live.lines.unshift(obj)
                store.live.raw += raw + '\n'
              },
            })
          } catch (e) {
            store.live.error = e.message
          }
        }

        async function toggleLive() {
          if (store.live.running) {
            try {
              store.live.controller?.abort()
            } catch {}
            store.live.running = false
            return
          }
          resetBuffer()
          store.live.running = true
          try {
            await readJSONLStream(queueId.value, {
              maxLines: Infinity,
              timeoutMs: Infinity,
              onLine(obj, raw) {
                store.live.lines.unshift(obj)
                store.live.raw += raw + '\n'
              },
            })
          } catch (e) {
            store.live.error = e.message
          } finally {
            store.live.running = false
          }
        }

        async function sendMessage() {
          sending.value = true
          try {
            await writeJSONLine(queueId.value, newMessage.value, contentType.value)
          } catch (e) {
            alert('Error al enviar: ' + e.message)
          } finally {
            sending.value = false
          }
        }

        watch(
          queueId,
          (v) => {
            store.selectedQueue = v
            resetBuffer()
          },
          { immediate: true }
        )

        const curlCmd = computed(() => {
          const url = `${store.baseUrl}/v1/queues/${encodeURIComponent(queueId.value)}:read`
          const header = store.extraHeaderName && store.extraHeaderValue ? ` -H "${store.extraHeaderName}: ${store.extraHeaderValue}"` : ''
          return `curl -N -s${header} "${url}"`
        })

        return { store, queueId, n, timeoutMs, newMessage, contentType, readN, toggleLive, sendMessage, curlCmd, resetBuffer, sending }
      },
      template: `
        <div class="app-main-content">
          <header class="app-page-header">
            <div>
              <p class="app-kicker">Cola activa</p>
              <h1 class="hc-heading-2">{{ queueId }}</h1>
              <p class="app-subtitle">Lectura en streaming (JSON Lines) y publicación de mensajes.</p>
            </div>
            <div class="app-header-actions">
              <button type="button" class="app-button app-button--ghost" @click="resetBuffer">Limpiar visor</button>
              <button
                type="button"
                class="app-button"
                :class="{ 'app-button--danger': store.live.running }"
                @click="toggleLive"
              >
                {{ store.live.running ? 'Detener LIVE' : 'Iniciar LIVE' }}
              </button>
            </div>
          </header>

          <div class="app-grid">
            <section class="app-grid-panel">
              <article class="hc-card app-card">
                <header class="app-card-header">
                  <div>
                    <p class="app-kicker">Consulta puntual</p>
                    <h2 class="app-card-title">Obtener mensajes</h2>
                  </div>
                </header>
                <div class="app-card-body">
                  <div class="app-field-grid">
                    <label class="app-field">
                      <span>Siguientes N</span>
                      <input v-model.number="n" type="number" min="1" class="app-input" />
                    </label>
                    <label class="app-field">
                      <span>Timeout (ms)</span>
                      <input v-model.number="timeoutMs" type="number" min="0" class="app-input" />
                    </label>
                  </div>
                  <div class="app-card-actions">
                    <button type="button" class="app-button app-button--secondary" @click="readN">Leer mensajes</button>
                  </div>
                  <p v-if="store.live.error" class="app-error">{{ store.live.error }}</p>
                </div>
              </article>

              <article class="hc-card app-card">
                <header class="app-card-header">
                  <div>
                    <p class="app-kicker">Publicar</p>
                    <h2 class="app-card-title">Crear mensaje</h2>
                  </div>
                </header>
                <div class="app-card-body">
                  <label class="app-field">
                    <span>Content-Type</span>
                    <select v-model="contentType" class="app-input">
                      <option>application/json</option>
                      <option>text/plain</option>
                    </select>
                  </label>
                  <label class="app-field">
                    <span>Payload</span>
                    <textarea v-model="newMessage" rows="6" spellcheck="false" class="app-input app-input--textarea"></textarea>
                  </label>
                  <div class="app-card-actions">
                    <button type="button" class="app-button" @click="sendMessage" :disabled="sending">Enviar mensaje</button>
                  </div>
                  <p class="app-helper">Se envía como una sola línea (JSONL). Para <code>application/json</code> se añade un salto de línea automático.</p>
                </div>
              </article>

              <article class="hc-card app-card">
                <header class="app-card-header">
                  <div>
                    <p class="app-kicker">CLI</p>
                    <h2 class="app-card-title">Comando cURL</h2>
                  </div>
                </header>
                <pre class="app-code"><code>{{ curlCmd }}</code></pre>
              </article>
            </section>

            <section class="app-grid-panel app-grid-panel--messages">
              <article class="hc-card app-card app-messages">
                <header class="app-card-header">
                  <div>
                    <p class="app-kicker">Live feed</p>
                    <h2 class="app-card-title">Mensajes recibidos</h2>
                  </div>
                  <span class="app-chip">{{ store.live.lines.length }} elementos</span>
                </header>
                <div class="app-messages-list">
                  <ul>
                    <li v-for="(m, i) in store.live.lines" :key="i">
                      <pre class="app-json">{{ JSON.stringify(m, null, 2) }}</pre>
                    </li>
                    <li v-if="!store.live.lines.length" class="app-empty-state">Sin datos aún. Inicia una lectura o habilita LIVE.</li>
                  </ul>
                </div>
              </article>
            </section>
          </div>
        </div>
      `,
    }

    const routes = [
      { path: '/', name: 'home', component: Home },
      { path: '/queue/:id', name: 'queue', component: QueueView, props: true },
    ]
    const router = createRouter({ history: createWebHashHistory(), routes })

    const App = {
      name: 'App',
      components: { Sidebar },
      setup() {
        onMounted(() => {
          listQueues().then(() => {
            if (store.queues.length && router.currentRoute.value.name === 'home') {
              const q = store.queues[0]
              store.selectedQueue = q
              router.replace({ name: 'queue', params: { id: q } })
            }
          })
        })
        return { store }
      },
      template: `
        <div class="app-shell">
          <aside class="app-sidebar">
            <div class="app-sidebar-header">
              <img src="../../ds/logo-short.png" alt="hola cloud" />
              <div>
                <span class="app-kicker">hola.cloud</span>
                <h1 class="app-brand-title">Tailon Console</h1>
                <p class="app-subtitle">Streaming queues toolkit</p>
              </div>
            </div>
            <Sidebar />
          </aside>
          <main class="app-main">
            <router-view />
          </main>
        </div>
      `,
    }

    createApp(App).use(router).mount('#app')
  </script>
</head>
<body class="app-body">
  <div id="app"></div>
</body>
</html>
